import type { Plugin, ViteDevServer } from 'vite'
import * as fs from 'fs'
import * as path from 'path'

type HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE'

type ApiRoute = {
  name: string
  path: string
  handlers: Record<string, ((ctx: any) => any) | undefined>
}

type FlatEndpoint = {
  name: string
  method: HttpMethod
  path: string
  handler: (ctx: any) => any
}

type MatchInfo = {
  regex: RegExp
  paramNames: string[]
}

function patternToRegex(pattern: string): MatchInfo {
  const paramNames: string[] = []
  const regexStr = pattern
    .replace(/\//g, '\\/')
    .replace(/:([A-Za-z0-9_]+)/g, (_m, p1) => {
      paramNames.push(p1)
      return `(?<${p1}>[^/]+)`
    })
  return { regex: new RegExp(`^${regexStr}$`), paramNames }
}

function urlPath(u: string): string {
  try {
    const parsed = new URL(u, 'http://localhost')
    return parsed.pathname.replace(/^\/api/, '') || '/'
  } catch {
    const noQuery = u.split('?')[0]
    return noQuery.replace(/^\/api/, '') || '/'
  }
}

async function readBody(req: any): Promise<any> {
  const chunks: Buffer[] = []
  return new Promise((resolve) => {
    req.on('data', (c: Buffer) => chunks.push(c))
    req.on('end', () => {
      const raw = Buffer.concat(chunks).toString('utf-8')
      try {
        resolve(raw ? JSON.parse(raw) : null)
      } catch {
        resolve(raw)
      }
    })
  })
}

function flattenRoutes(routes: ApiRoute[]): FlatEndpoint[] {
  const endpoints: FlatEndpoint[] = []
  for (const route of routes) {
    for (const [method, handler] of Object.entries(route.handlers)) {
      if (handler) {
        endpoints.push({
          name: route.name,
          method: method as HttpMethod,
          path: route.path,
          handler,
        })
      }
    }
  }
  return endpoints
}

function generateClientApi(root: string, endpoints: FlatEndpoint[]) {
  const outPath = path.resolve(root, 'src/app/$api.ts')
  const dir = path.dirname(outPath)
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true })
  }

  const lines: string[] = []
  lines.push(`// Auto-generated by auwla-api plugin. Do not edit manually.`)
  lines.push(``)
  lines.push(`export type Query = Record<string, string | number>`)
  lines.push(`export type Params = Record<string, string | number>`)
  lines.push(``)
  lines.push(`function toQuery(q?: Query): string {`)
  lines.push(`  if (!q || Object.keys(q).length === 0) return ''`)
  lines.push(`  const usp = new URLSearchParams(Object.entries(q).map(([k,v]) => [k, String(v)]))`)
  lines.push(`  return usp.toString() ? ('?' + usp.toString()) : ''`)
  lines.push(`}`)
  lines.push(``)
  lines.push(`function buildUrl(path: string, params?: Params, query?: Query): string {`)
  lines.push(`  let p = path`)
  lines.push(`  if (params) {`)
  lines.push(`    for (const [k,v] of Object.entries(params)) {`)
  lines.push(`      p = p.replace(':' + k, encodeURIComponent(String(v)))`)
  lines.push(`    }`)
  lines.push(`  }`)
  lines.push(`  return '/api' + p + toQuery(query)`)
  lines.push(`}`)
  lines.push(``)

  const byName = new Map<string, FlatEndpoint[]>()
  for (const e of endpoints) {
    const arr = byName.get(e.name) || []
    arr.push(e)
    byName.set(e.name, arr)
  }

  lines.push(`export const $api = {`)

  for (const [name, group] of byName.entries()) {
    lines.push(`  /** ${group.map((e) => `${e.method} ${e.path}`).join(' | ')} */`)
    lines.push(`  ${name}: {`)

    for (const endpoint of group) {
      const methodLower = endpoint.method.toLowerCase()
      lines.push(`    ${methodLower}: (args?: { params?: Params; query?: Query; body?: any }, init?: RequestInit) => {`)
      lines.push(`      const url = buildUrl('${endpoint.path}', args?.params, args?.query)`)
      lines.push(`      return fetch(url, {`)
      lines.push(`        method: '${endpoint.method}',`)
      lines.push(`        headers: { 'Content-Type': 'application/json' },`)
      lines.push(`        body: args?.body ? JSON.stringify(args.body) : undefined,`)
      lines.push(`        ...(init || {})`)
      lines.push(`      }).then(r => r.json())`)
      lines.push(`    },`)
    }

    lines.push(`  },`)
  }

  lines.push(`} as const`)

  fs.writeFileSync(outPath, lines.join('\n'), 'utf-8')
}

async function loadApiRoutes(server: ViteDevServer): Promise<ApiRoute[]> {
  try {
    const apiPath = path.resolve(server.config.root, 'server/api.ts')
    const fileUrl = '/@fs/' + apiPath.replace(/\\/g, '/')

    const mod = await server.ssrLoadModule(fileUrl)

    const routes: ApiRoute[] = mod.apiRoutes || mod.default || []

    server.config.logger.info(`[auwla-api] Loaded ${routes.length} route(s) from server/api.ts`)

    return routes
  } catch (e) {
    server.config.logger.error(`[auwla-api] Failed to load routes: ${String(e)}`)
    return []
  }
}

export function apiRoutesPlugin(): Plugin {
  let root = ''
  let endpoints: FlatEndpoint[] = []
  let matchers: { endpoint: FlatEndpoint; matcher: MatchInfo }[] = []

  const rebuildMatchers = () => {
    matchers = endpoints.map((e) => ({ endpoint: e, matcher: patternToRegex(e.path) }))
  }

  return {
    name: 'auwla-api',

    configResolved(config) {
      root = config.root
    },

    async configureServer(server) {
      const routes = await loadApiRoutes(server)
      endpoints = flattenRoutes(routes)

      if (endpoints.length === 0) {
        server.config.logger.warn('[auwla-api] No endpoints found')
      }

      rebuildMatchers()
      generateClientApi(root, endpoints)

      server.middlewares.use(async (req, res, next) => {
        if (!req.url || !req.method) return next()
        if (!req.url.startsWith('/api')) return next()

        const method = req.method.toUpperCase() as HttpMethod
        const pathname = urlPath(req.url)

        const matched = matchers.find((m) => m.endpoint.method === method && m.matcher.regex.test(pathname))

        if (!matched) {
          res.statusCode = 404
          res.setHeader('Content-Type', 'application/json')
          res.end(JSON.stringify({ error: 'Not Found' }))
          return
        }

        try {
          const handler = matched.endpoint.handler

          if (typeof handler !== 'function') {
            throw new Error(`Handler not found for ${matched.endpoint.name}`)
          }

          const body = await readBody(req)
          const urlObj = new URL(req.url!, 'http://localhost')
          const paramsMatch = matched.matcher.regex.exec(pathname)
          const params = paramsMatch?.groups || {}
          const query: Record<string, string> = {}
          for (const [k, v] of urlObj.searchParams.entries()) {
            query[k] = v
          }

          const result = await handler({ req, res, params, query, body })

          if (!res.headersSent) {
            res.setHeader('Content-Type', 'application/json')
            res.end(JSON.stringify(result ?? null))
          }
        } catch (e) {
          res.statusCode = 500
          res.setHeader('Content-Type', 'application/json')
          res.end(JSON.stringify({ error: 'Internal Server Error', detail: String(e) }))
        }
      })
    },

    async handleHotUpdate(ctx) {
      if (ctx.file.includes(path.sep + 'server' + path.sep + 'api.ts')) {
        try {
          const routes = await loadApiRoutes(ctx.server)
          endpoints = flattenRoutes(routes)
          rebuildMatchers()
          generateClientApi(root, endpoints)
          ctx.server.config.logger.info('[auwla-api] Hot reloaded')
        } catch (e) {
          ctx.server.config.logger.error(`[auwla-api] Hot reload failed: ${String(e)}`)
        }
      }
    },
  }
}

export default apiRoutesPlugin
