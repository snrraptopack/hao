import type { Plugin } from 'vite'
import * as fs from 'fs'
import * as path from 'path'
import * as ts from 'typescript'

interface RouteInfo {
  path: string
  name?: string
}

interface GroupInfo {
  basePath: string
  routes: RouteInfo[]
}

/**
 * Vite plugin that automatically generates route types by scanning route definitions.
 * 
 * This plugin:
 * 1. Watches route files for changes
 * 2. Extracts paths and names from defineRoutes() and group() calls
 * 3. Generates src/app/route-types.d.ts with all registered routes
 * 4. Provides IDE autocomplete for useTypedParams, Link, router.push, etc.
 * 
 * Usage in vite.config.ts:
 * ```ts
 * import { routeTypesPlugin } from './scripts/vite-plugin-route-types'
 * 
 * export default defineConfig({
 *   plugins: [routeTypesPlugin()]
 * })
 * ```
 */
export function routeTypesPlugin(): Plugin {
  let root: string
  let routesFilePath: string
  let typesFilePath: string
  
  return {
    name: 'auwla-route-types',
    
    configResolved(config) {
      root = config.root
      routesFilePath = path.resolve(root, 'src/app/routes.tsx')
      typesFilePath = path.resolve(root, 'src/app/route-types.d.ts')
    },
    
    async buildStart() {
      await generateRouteTypes(routesFilePath, typesFilePath)
    },
    
    handleHotUpdate({ file }) {
      // Regenerate types when route files change
      if (file.includes('/routes.tsx') || file.includes('\\routes.tsx') || file.includes('/routes.ts') || file.includes('\\routes.ts')) {
        generateRouteTypes(routesFilePath, typesFilePath)
      }
    },
  }
}

async function generateRouteTypes(routesFile: string, outputFile: string) {
  try {
    const content = fs.readFileSync(routesFile, 'utf-8')
    const routes = extractRoutes(content)
    
    // Deduplicate paths and names
    const pathsSet = new Set(routes.map(r => r.path).filter(Boolean))
    const namesSet = new Set(routes.map(r => r.name).filter(Boolean))
    
    const paths = Array.from(pathsSet).sort()
    const names = Array.from(namesSet).sort()
    
    const pathsUnion = paths.length > 0 
      ? paths.map(p => `'${p}'`).join(' | ')
      : 'never'
    
    const namesUnion = names.length > 0
      ? names.map(n => `'${n}'`).join(' | ')
      : 'never'
    
    // Generate name-to-path mapping (use the first occurrence of each name)
    const nameToPath = new Map<string, string>()
    for (const route of routes) {
      if (route.name && route.path && !nameToPath.has(route.name)) {
        nameToPath.set(route.name, route.path)
      }
    }
    
    const namePathPairs = Array.from(nameToPath.entries())
      .sort(([a], [b]) => a.localeCompare(b))
      .map(([name, path]) => `    '${name}': '${path}'`)
      .join(';\n')
    
    const typeDefinition = `// Auto-generated by vite-plugin-route-types
// Do not edit manually - this file is regenerated on each build
// Generated from: src/app/routes.tsx

type AllRoutes = typeof import('./routes').allRoutes;

// Export the paths type so it can be imported and used directly
export type AppRoutePaths = ${pathsUnion};
export type AppRouteNames = ${namesUnion};

declare global {
  interface AuwlaRouterAppPaths {
    paths: AppRoutePaths;
    names: AppRouteNames;
  }
  
  interface AuwlaRoutePathsByName {
${namePathPairs ? namePathPairs + ';' : '    // No named routes defined yet'}
  }
}

export {}
`
    
    // Only write if content changed to avoid unnecessary rebuilds
    let shouldWrite = true
    if (fs.existsSync(outputFile)) {
      const existing = fs.readFileSync(outputFile, 'utf-8')
      shouldWrite = existing !== typeDefinition
    }
    
    if (shouldWrite) {
      fs.writeFileSync(outputFile, typeDefinition, 'utf-8')
      console.log(`[plugin auwla-route-types] Route types generated â€¢ paths=${paths.length} names=${names.length} pairs=${routes.filter(r => r.name && r.path).length}`)
    }
  } catch (err) {
    console.error('[plugin auwla-route-types] Failed to generate route types:', err)
  }
}

/**
 * Extract route paths and names from the routes file using TypeScript AST.
 * Handles:
 * - defineRoutes([{ path: '/', name: 'home' }])
 * - group('/app', {}, [...])
 * - composeRoutes(...) 
 * - Nested structures
 */
function extractRoutes(content: string): RouteInfo[] {
  const sourceFile = ts.createSourceFile(
    'routes.tsx',
    content,
    ts.ScriptTarget.Latest,
    true
  )
  
  const allRoutes: RouteInfo[] = []
  const groups: GroupInfo[] = []
  
  function visit(node: ts.Node) {
    // Look for defineRoutes calls
    if (ts.isCallExpression(node)) {
      const expression = node.expression
      
      // defineRoutes([...])
      if (ts.isIdentifier(expression) && expression.text === 'defineRoutes') {
        const arrayArg = node.arguments[0]
        if (arrayArg && ts.isArrayLiteralExpression(arrayArg)) {
          extractRoutesFromArrayLiteral(arrayArg, allRoutes, '')
        }
      }
      
      // group('/base', {}, routes)
      if (ts.isIdentifier(expression) && expression.text === 'group') {
        const basePathArg = node.arguments[0]
        const routesArg = node.arguments[2]
        
        if (basePathArg && ts.isStringLiteral(basePathArg)) {
          const basePath = basePathArg.text
          const groupRoutes: RouteInfo[] = []
          
          // Handle different route arguments
          if (routesArg) {
            if (ts.isArrayLiteralExpression(routesArg)) {
              extractRoutesFromArrayLiteral(routesArg, groupRoutes, '')
            } else if (ts.isCallExpression(routesArg)) {
              // It's composeRoutes, defineRoutes, or another group
              // We need to extract from these recursively
              extractRoutesFromCallExpression(routesArg, groupRoutes, '')
            } else if (ts.isIdentifier(routesArg)) {
              // It's a variable reference - we'd need to resolve it
              // For now, skip (would need full type checking)
            }
          }
          
          // Apply the group base path to all extracted routes
          const transformedRoutes = groupRoutes.map(r => ({
            ...r,
            path: joinPaths(basePath, r.path)
          }))
          
          allRoutes.push(...transformedRoutes)
        }
      }
      
      // composeRoutes(...) - recursively process arguments
      if (ts.isIdentifier(expression) && expression.text === 'composeRoutes') {
        for (const arg of node.arguments) {
          if (ts.isCallExpression(arg)) {
            extractRoutesFromCallExpression(arg, allRoutes, '')
          } else if (ts.isIdentifier(arg)) {
            // Variable reference - would need full resolution
          }
        }
      }
    }
    
    ts.forEachChild(node, visit)
  }
  
  visit(sourceFile)
  return allRoutes
}

function extractRoutesFromCallExpression(node: ts.CallExpression, routes: RouteInfo[], groupBase: string) {
  const expression = node.expression
  
  if (ts.isIdentifier(expression)) {
    if (expression.text === 'defineRoutes') {
      const arrayArg = node.arguments[0]
      if (arrayArg && ts.isArrayLiteralExpression(arrayArg)) {
        extractRoutesFromArrayLiteral(arrayArg, routes, groupBase)
      }
    } else if (expression.text === 'composeRoutes') {
      for (const arg of node.arguments) {
        if (ts.isCallExpression(arg)) {
          extractRoutesFromCallExpression(arg, routes, groupBase)
        }
      }
    }
  }
}

function extractRoutesFromArrayLiteral(arrayNode: ts.ArrayLiteralExpression, routes: RouteInfo[], groupBase: string) {
  for (const element of arrayNode.elements) {
    if (ts.isObjectLiteralExpression(element)) {
      let pathValue: string | undefined
      let nameValue: string | undefined
      
      for (const prop of element.properties) {
        if (ts.isPropertyAssignment(prop)) {
          const propName = prop.name
          const propValue = prop.initializer
          
          if (ts.isIdentifier(propName) && propName.text === 'path') {
            if (ts.isStringLiteral(propValue)) {
              pathValue = propValue.text
            }
          }
          
          if (ts.isIdentifier(propName) && propName.text === 'name') {
            if (ts.isStringLiteral(propValue)) {
              nameValue = propValue.text
            }
          }
        }
      }
      
      if (pathValue) {
        const fullPath = groupBase ? joinPaths(groupBase, pathValue) : pathValue
        routes.push({ path: fullPath, name: nameValue })
      }
    }
  }
}

function joinPaths(base: string, child: string): string {
  const b = base.endsWith('/') ? base.slice(0, -1) : base
  const c = child.startsWith('/') ? child : `/${child}`
  return `${b}${c}` || '/'
}
