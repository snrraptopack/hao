<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BLE Device Tester</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 40px;
            max-width: 400px;
            width: 100%;
        }

        h1 {
            color: #333;
            font-size: 24px;
            margin-bottom: 10px;
            text-align: center;
        }

        .subtitle {
            color: #666;
            font-size: 14px;
            text-align: center;
            margin-bottom: 30px;
        }

        .status {
            background: #f7f7f7;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 14px;
        }

        .status.connected {
            background: #d4edda;
            color: #155724;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
        }

        button {
            width: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 15px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-bottom: 10px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .data-container {
            background: #f7f7f7;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }

        .data-container.active {
            display: block;
        }

        .data-item {
            padding: 8px 0;
            border-bottom: 1px solid #e0e0e0;
            font-size: 13px;
            color: #333;
        }

        .data-item:last-child {
            border-bottom: none;
        }

        .data-item .time {
            color: #999;
            font-size: 11px;
        }

        .data-item .value {
            color: #667eea;
            font-weight: 600;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .device-info {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🔵 BLE Tester</h1>
        <p class="subtitle">Connect to Bluetooth Low Energy devices</p>
        
        <div id="status" class="status">
            Ready to connect
        </div>

        <button id="connectBtn">Connect Device (Filtered)</button>
        <button id="connectAllBtn">Show All Devices</button>
        <button id="disconnectBtn" style="display: none; background: #dc3545;">Disconnect</button>
        
        <div id="pollingControls" style="display: none; margin-top: 10px;">
            <button id="startPolling" style="background: #28a745; font-size: 14px; padding: 10px;">📡 Start Continuous Reading</button>
        </div>

        <div id="deviceInfo" class="device-info"></div>

        <div id="dataContainer" class="data-container">
            <strong style="display: block; margin-bottom: 10px; color: #333;">📊 Live Data:</strong>
            <div id="dataList"></div>
        </div>
    </div>

    <script>
        let device = null;
        let pollingInterval = null;
        let readableCharacteristics = [];

        const statusDiv = document.getElementById('status');
        const connectBtn = document.getElementById('connectBtn');
        const connectAllBtn = document.getElementById('connectAllBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const pollingControls = document.getElementById('pollingControls');
        const startPollingBtn = document.getElementById('startPolling');
        const deviceInfo = document.getElementById('deviceInfo');
        const dataContainer = document.getElementById('dataContainer');
        const dataList = document.getElementById('dataList');
        const utf8Decoder = new TextDecoder();

        function updateStatus(message, type = 'normal') {
            statusDiv.textContent = message;
            statusDiv.className = 'status';
            if (type === 'connected') statusDiv.classList.add('connected');
            if (type === 'error') statusDiv.classList.add('error');
        }

        // Map of common BLE characteristic UUIDs to readable names
        const characteristicNames = {
            '00002a00': 'Device Name',
            '00002a01': 'Appearance',
            '00002a04': 'Peripheral Preferred Connection Parameters',
            '00002a05': 'Service Changed',
            '00002a19': 'Battery Level',
            '00002a29': 'Manufacturer Name',
            '00002a24': 'Model Number',
            '00002a25': 'Serial Number',
            '00002a27': 'Hardware Revision',
            '00002a26': 'Firmware Revision',
            '00002a28': 'Software Revision',
            '00002a37': 'Heart Rate Measurement',
            '00002a38': 'Body Sensor Location',
            '00002a39': 'Heart Rate Control Point',
            '00002aa6': 'Central Address Resolution'
        };

        function getCharacteristicName(uuid) {
            const shortUuid = uuid.substring(0, 8).toLowerCase();
            return characteristicNames[shortUuid] || uuid.substring(0, 8) + '...';
        }

        function addDataItem(value) {
            const now = new Date().toLocaleTimeString();
            const item = document.createElement('div');
            item.className = 'data-item';
            item.innerHTML = `
                <div class="time">${now}</div>
                <div class="value">${value}</div>
            `;
            dataList.insertBefore(item, dataList.firstChild);
            
            // Keep only last 20 items
            if (dataList.children.length > 20) {
                dataList.removeChild(dataList.lastChild);
            }
        }

        function getByteArray(value) {
            if (!value) return new Uint8Array();
            if (value instanceof Uint8Array) return value;
            if (value instanceof DataView) {
                return new Uint8Array(value.buffer, value.byteOffset, value.byteLength);
            }
            if (value instanceof ArrayBuffer) return new Uint8Array(value);
            if (ArrayBuffer.isView(value)) {
                return new Uint8Array(value.buffer, value.byteOffset, value.byteLength);
            }
            return new Uint8Array();
        }

        function getDataView(value) {
            if (value instanceof DataView) return value;
            if (value instanceof ArrayBuffer) return new DataView(value);
            if (ArrayBuffer.isView(value)) {
                return new DataView(value.buffer, value.byteOffset, value.byteLength);
            }
            return new DataView(new ArrayBuffer(0));
        }

        function isPrintableAscii(bytes) {
            if (!bytes.length) return false;
            for (const byte of bytes) {
                if ((byte >= 32 && byte <= 126) || byte === 9 || byte === 10 || byte === 13) continue;
                return false;
            }
            return true;
        }

        function formatGattValue(value) {
            const bytesView = getByteArray(value);
            const length = bytesView.length;
            if (length === 0) return 'Raw: []';

            const dataView = getDataView(value);
            const bytes = Array.from(bytesView);
            const hex = bytes.map((byte) => byte.toString(16).padStart(2, '0').toUpperCase());
            const lines = [
                `Raw: [${bytes.join(', ')}]`,
                `Hex: ${hex.join(' ')}`
            ];

            if (isPrintableAscii(bytesView)) {
                const ascii = utf8Decoder.decode(bytesView).replace(/\0+$/g, '');
                lines.push(`ASCII: "${ascii}"`);
            }

            if (length >= 1) {
                lines.push(`u8 / s8: ${dataView.getUint8(0)} / ${dataView.getInt8(0)}`);
            }

            if (length >= 2) {
                lines.push(`u16 LE / BE: ${dataView.getUint16(0, true)} / ${dataView.getUint16(0, false)}`);
                lines.push(`s16 LE / BE: ${dataView.getInt16(0, true)} / ${dataView.getInt16(0, false)}`);
            }

            if (length >= 4) {
                lines.push(`u32 LE / BE: ${dataView.getUint32(0, true)} / ${dataView.getUint32(0, false)}`);
                lines.push(`s32 LE / BE: ${dataView.getInt32(0, true)} / ${dataView.getInt32(0, false)}`);

                const float32Le = dataView.getFloat32(0, true);
                const float32Be = dataView.getFloat32(0, false);
                const floatParts = [];
                if (Number.isFinite(float32Le)) floatParts.push(`LE ${float32Le}`);
                if (Number.isFinite(float32Be)) floatParts.push(`BE ${float32Be}`);
                if (floatParts.length) lines.push(`float32: ${floatParts.join(' | ')}`);
            }

            if (length >= 8) {
                const float64Le = dataView.getFloat64(0, true);
                const float64Be = dataView.getFloat64(0, false);
                const doubleParts = [];
                if (Number.isFinite(float64Le)) doubleParts.push(`LE ${float64Le}`);
                if (Number.isFinite(float64Be)) doubleParts.push(`BE ${float64Be}`);
                if (doubleParts.length) lines.push(`float64: ${doubleParts.join(' | ')}`);
            }

            return lines.join('<br>');
        }

        function logGattValue(prefix, charName, value) {
            const header = charName ? `${prefix} ${charName}` : prefix;
            const formatted = formatGattValue(value);
            addDataItem(`${header}<br>${formatted}`);
        }

        connectBtn.addEventListener('click', async () => {
            try {
                updateStatus('Scanning for devices...');
                connectBtn.innerHTML = '<span class="spinner"></span> Scanning...';
                connectBtn.disabled = true;

                // Request any Bluetooth device with common services
                device = await navigator.bluetooth.requestDevice({
                    // Remove acceptAllDevices and use filters instead
                    filters: [
                        { services: ['battery_service'] },
                        { services: ['heart_rate'] },
                        { services: ['device_information'] },
                        { services: ['generic_access'] },
                        { namePrefix: 'BLE' },
                        { namePrefix: 'Bluetooth' },
                        { namePrefix: 'Arduino' },
                        { namePrefix: 'ESP32' },
                        { namePrefix: 'HC-' },
                        { namePrefix: 'MLT-BT' },
                    ],
                    optionalServices: [
                        'generic_access',
                        'generic_attribute', 
                        'battery_service', 
                        'heart_rate', 
                        'device_information',
                        '0000fff0-0000-1000-8000-00805f9b34fb', // Common custom service
                        '6e400001-b5a3-f393-e0a9-e50e24dcca9e'  // Nordic UART Service
                    ]
                });

                updateStatus('Connecting...', 'normal');
                
                // Connect to GATT Server
                const server = await device.gatt.connect();
                readableCharacteristics = [];
                
                updateStatus(`✓ Connected to ${device.name || 'Unknown Device'}`, 'connected');
                deviceInfo.textContent = `Device ID: ${device.id}`;
                
                connectBtn.style.display = 'none';
                disconnectBtn.style.display = 'block';
                dataContainer.classList.add('active');

                // Try to read device info and discover ALL services
                try {
                    addDataItem(`🔍 Discovering services...`);
                    const services = await server.getPrimaryServices();
                    addDataItem(`✅ Found ${services.length} service(s)`);
                    addDataItem(`━━━━━━━━━━━━━━━━━━━━━━━━━`);
                    
                    if (services.length === 1) {
                        addDataItem(`⚠️ Only 1 service found. Device may have custom services that need explicit UUIDs to access.`);
                    }
                    
                    for (const service of services) {
                        addDataItem(`📦 Service: ${service.uuid}`);
                        
                        try {
                            const characteristics = await service.getCharacteristics();
                            for (const char of characteristics) {
                                const charLabel = getCharacteristicName(char.uuid);
                                addDataItem(`Characteristic: ${charLabel}`);
                                
                                // Try to read if possible
                                if (char.properties.read) {
                                    try {
                                        const value = await char.readValue();
                                        logGattValue('📖 Read', charLabel, value);
                                    } catch (e) {
                                        console.log('Could not read characteristic');
                                    }
                                }

                                // Try to subscribe to notifications
                                if (char.properties.notify) {
                                    try {
                                        await char.startNotifications();
                                        char.addEventListener('characteristicvaluechanged', (event) => {
                                            logGattValue('🔔 Notify', charLabel, event.target.value);
                                        });
                                        addDataItem(`🔔 Subscribed to notifications`);
                                    } catch (e) {
                                        console.log('Could not subscribe to notifications');
                                    }
                                }
                            }
                        } catch (e) {
                            console.log('Could not get characteristics');
                        }
                    }
                } catch (error) {
                    addDataItem(`ℹ️ Could not read device info`);
                }

            } catch (error) {
                updateStatus(`❌ ${error.message}`, 'error');
                connectBtn.innerHTML = 'Connect Device';
                connectBtn.disabled = false;
                console.error('Error:', error);
            }
        });

        // "Show All Devices" button - shows everything including unsupported
        connectAllBtn.addEventListener('click', async () => {
            try {
                updateStatus('Scanning all devices...');
                connectAllBtn.innerHTML = '<span class="spinner"></span> Scanning...';
                connectAllBtn.disabled = true;
                connectBtn.disabled = true;

                device = await navigator.bluetooth.requestDevice({
                    acceptAllDevices: true,
                    // Request access to ALL services (critical for custom devices!)
                    optionalServices: [
                        'generic_access', 
                        'generic_attribute',
                        'battery_service', 
                        'heart_rate', 
                        'device_information'
                        // Note: Custom services will still be discovered but may have limited access
                    ]
                });

                updateStatus('Connecting...', 'normal');
                const server = await device.gatt.connect();
                readableCharacteristics = [];
                
                updateStatus(`✓ Connected to ${device.name || 'Unknown Device'}`, 'connected');
                deviceInfo.textContent = `Device ID: ${device.id}`;
                
                connectBtn.style.display = 'none';
                connectAllBtn.style.display = 'none';
                disconnectBtn.style.display = 'block';
                pollingControls.style.display = 'block';
                dataContainer.classList.add('active');

                // Try to read device info
                try {
                    const services = await server.getPrimaryServices();
                    addDataItem(`Found ${services.length} service(s)`);
                    
                    for (const service of services) {
                        addDataItem(`Service: ${service.uuid}`);
                        
                        try {
                            const characteristics = await service.getCharacteristics();
                            for (const char of characteristics) {
                                const charName = getCharacteristicName(char.uuid);
                                addDataItem(`📝 ${charName}`);
                                
                                // Show properties
                                const props = [];
                                if (char.properties.read) props.push('✅ Read');
                                if (char.properties.write) props.push('✍️ Write');
                                if (char.properties.writeWithoutResponse) props.push('✍️ WriteNoResponse');
                                if (char.properties.notify) props.push('🔔 Notify');
                                if (char.properties.indicate) props.push('📣 Indicate');
                                addDataItem(`   Properties: ${props.join(', ')}`);
                                
                                // Highlight if device needs activation
                                if (char.properties.write || char.properties.writeWithoutResponse) {
                                    addDataItem(`   💡 This characteristic accepts commands!`);
                                }
                                
                                if (char.properties.read) {
                                    // Store readable characteristics for polling
                                    readableCharacteristics.push({char, charName});
                                    
                                    try {
                                        const value = await char.readValue();
                                        logGattValue('📖 Read', charName, value);
                                    } catch (e) {
                                        addDataItem(`❌ Could not read`);
                                        console.log('Could not read characteristic');
                                    }
                                }

                                if (char.properties.notify) {
                                    try {
                                        await char.startNotifications();
                                        char.addEventListener('characteristicvaluechanged', (event) => {
                                            logGattValue('🔔 Notify', charName, event.target.value);
                                        });
                                        addDataItem(`🔔 Subscribed to notifications`);
                                    } catch (e) {
                                        console.log('Could not subscribe to notifications');
                                    }
                                }
                            }
                        } catch (e) {
                            console.log('Could not get characteristics');
                        }
                    }
                } catch (error) {
                    addDataItem(`ℹ️ Could not read device info`);
                }

            } catch (error) {
                updateStatus(`❌ ${error.message}`, 'error');
                connectAllBtn.innerHTML = 'Show All Devices';
                connectAllBtn.disabled = false;
                connectBtn.disabled = false;
                console.error('Error:', error);
            }
        });

        // Start continuous polling
        startPollingBtn.addEventListener('click', () => {
            if (pollingInterval) {
                // Stop polling
                clearInterval(pollingInterval);
                pollingInterval = null;
                startPollingBtn.textContent = '📡 Start Continuous Reading';
                startPollingBtn.style.background = '#28a745';
                addDataItem('⏸️ Stopped continuous reading');
            } else {
                // Start polling
                if (readableCharacteristics.length === 0) {
                    addDataItem('❌ No readable characteristics found');
                    return;
                }
                
                startPollingBtn.textContent = '⏸️ Stop Reading';
                startPollingBtn.style.background = '#ffc107';
                addDataItem('▶️ Started continuous reading (every 2s)');
                
                pollingInterval = setInterval(async () => {
                    for (const {char, charName} of readableCharacteristics) {
                        try {
                            const value = await char.readValue();
                            logGattValue('🔄', charName, value);
                        } catch (e) {
                            console.log('Could not read characteristic during polling');
                        }
                    }
                }, 2000); // Poll every 2 seconds
            }
        });

        disconnectBtn.addEventListener('click', () => {
            if (pollingInterval) {
                clearInterval(pollingInterval);
                pollingInterval = null;
            }
            if (device && device.gatt.connected) {
                device.gatt.disconnect();
            }
            updateStatus('Disconnected');
            connectBtn.style.display = 'block';
            connectAllBtn.style.display = 'block';
            connectBtn.innerHTML = 'Connect Device (Filtered)';
            connectAllBtn.innerHTML = 'Show All Devices';
            connectBtn.disabled = false;
            connectAllBtn.disabled = false;
            disconnectBtn.style.display = 'none';
            pollingControls.style.display = 'none';
            startPollingBtn.textContent = '📡 Start Continuous Reading';
            startPollingBtn.style.background = '#28a745';
            deviceInfo.textContent = '';
            dataContainer.classList.remove('active');
            dataList.innerHTML = '';
            readableCharacteristics = [];
        });

        // Check if Web Bluetooth is supported
        if (!navigator.bluetooth) {
            updateStatus('❌ Web Bluetooth not supported. Use Chrome/Edge.', 'error');
            connectBtn.disabled = true;
        }
    </script>
</body>
</html>
